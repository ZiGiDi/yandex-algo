package sprint3.review.a;

public class Solution {


//    Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию,
//    и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив,
//    но сдвинула данные исходной отсортированной последовательности. Теперь массив не является отсортированным.
//    Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logn).
//      Можно предполагать, что в массиве только уникальные элементы.
//      От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Обратите внимание, что считывать данные и выводить ответ не требуется.

        /*
    id: https://contest.yandex.ru/contest/23815/run-report/90294333/

-- ПРИНЦИП РАБОТЫ --
принцип работы довольно-таки прост. Мы  делим массив пополам и находим средний эллемент в этом массиве.
Т.к. у нас массив сломан, но частично отсортирован. Эта самая сортировка может быть сломана в левой, или в правой части.
Как понять, что сломана сортировка? В нормальной сортировке предыдущий элемент меньше последующего.
Начинаем проверять рассматриваемы границы и сравнивать их друг с другом. Если порядок сортиовки не меняется в рассматриваемом
(левый граница - цент/центр - правая граница) и число лежит в пределах величин этих границ, то число явно находится в этом промежутке,
Иначе выбирай другой и продолжаем поиск также только границы рассматриваемого сдвигаем на этот промежуток и заново выбираем средний элемент.
И так продолжается, пока мы не нашли средним искомое число, при каждой итерации мы рассматриваем только нужную нам половину,
и имеем аналог бинарного поиска с учетом сломанности массива.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Т.к. у нас фиксированный массив, элементы частично отсортированы со сдвигом,
в основе реализации поиска лежит аналог бинарного поиска,
но с измененным алгоритмом поиска с учетом входных данных о формате сломаности массива,
Если при рассмотрении трех точек(2 крайнии и центр) между любыми 2 ближними сохраняется условие,
что предстоящий меньше последующего и число лежит в этой границе, то поиск и будет происходить там,
Т.к. та не нарушена последовательность, В случае, если число не попадает в этот промежуток,
значит будет происходить поиск вдругой половине. Т.к. других вариантов нет.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Т.к. мы в каждой итерации рассматриваем только конкретные 3 элемента с определенным индексом из массива,
нахождение этих элементов нам стоит О(1). С каждой итерацией область нашего поиска сокращается в двое, пока мы не найдем искомы элемент.
Максимальное количество раз, которое мы можем итерироваться -  O(logn).
Итого: 3*О(1)*O(logn) = O(logn)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В данной реализации используется память только для хранения 3 индексов, по которому происходит поиск.
Итого: O(1) т.к. память выделяется только под 3 элемента
*/


    public static int brokenSearch(int[] arr, int k) {

        int leftIndex = 0;
        int rightIndex = arr.length - 1;

        while (leftIndex <= rightIndex) {

            int midIndex = (leftIndex + rightIndex) / 2;
            if (arr[midIndex] == k) {
                return midIndex;
            }

            if (arr[leftIndex] <= arr[midIndex]) {
                if (arr[leftIndex] <= k && k < arr[midIndex]) {
                    rightIndex = midIndex - 1;
                } else {
                    leftIndex = midIndex + 1;
                }
            } else {
                if (arr[midIndex] < k && k <= arr[rightIndex]) {
                    leftIndex = midIndex + 1;
                } else {
                    rightIndex = midIndex - 1;
                }
            }
        }
        return -1;
    }

    private static void test() {
        int[] arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
        assert 6 == brokenSearch(arr, 5);
    }
}
